A very sad thing about modern man is that computers are ubiquitous to
everyone's life, yet there are very few people (even among
programmers!), who have any idea how to use them. This text will
contain a quick overview of several topics on the practice of
computing from "how to set up your shell" and "how to get
documentation" to "how to write better programs". Most of such
subjects, of course, require much more than a quick overview, so
when possible I'll try to describe how to get proper introduction
and reference manual to each subject.


FILE HIERARCHIES

This document focuses on maintaining good file hierarchies under
Unices, and so many consequent presumptions and opinions are taken.

File hierarchies are hard. What makes it worse is that we've all been
damaged from childhood with all those graphical file-managing tools
that are both slower than the command line and promote some very bad
habits. Natural consequences of such damage are even getting
standardised: there are a lot of programs that create weirdly-named
dirs like ~/Downloads and ~/Documents, and there is the XDG base dir
specification. It is my opinion that file hierarchies should
facilitate three things primarily:

1. It should be easy to navigate to the file by typing its name.
2. It should be easy to manipulate files via scripts.
3. It should be easy to perform similar operations on a group of
closely-related files, e.g. with only one or two commands all my
configs for $program should be able to be archived, copied, change
permissions and ownership etc.

Generally I assume that the user is not an idiot and knows where
most of his files are and can find the rest with find(1) or locate(1)
or something.

Firstly if you are reading this document, you probably aren't a
secretary, are you? Well, don't name your files like one! Use only
[A-Za-z0-9_.-]. Avoid minuses (dashes/whatever) as the first
character (or at all, really): they cause all sorts of problems like
"rm -i *" becoming "rm -i -f file1 file2", and there seems to be a
correlation between people who put a lot of dashes in their names and
the ones that end up unwieldily-named files. Minuses are OK for
semantic purposes, however, such as naming files after dates
("2013-05-05.photo.jpg" (though depending on how it will be used it
might be fine to name it "20130505.photo.jpg")), or versioning them
("prog-0.4.tar"). If you use them for separating "fields" in
filenames, consider using periods instead. There are also some
characters, which are not mandated by posix, but which are still
commonly used by some programs: comma (,) and colon (:) are used in
maildirs, I believe some GNU utilities like tilde (~), I think
systemd uses at (@), Linux's filesystems like pluses (+) for special
files/dirs and test(1) can often be invoked as `['. I'd advise
against using those for normal files, however. Be conservative with
numbers and underscores and only capitalise letters with VERY
IMPROTANT files that should be sorted first like README, Makefile,
CHANGES, INSTALL etc. That is not to name directories in your ~ so:
they already are sorted because the "unimportant" files have a period
as the first character.

Naturally, keep the names short. Of course if you have some, e.g.,
photo saved on your disc, but you only open it once a decade, it's
fine to give it a longer, more descriptive name like
"1998.tortoise_on_red_sea_beach.png" (do tortoises live on the Red
sea?). On the other hand if you have a copy of "the brave soldier
Schweik" on the disc, there is no need to name it
"the_fateful_adventures_of_the_brave_soldier_schweik_during_the_world_war_by_jaroslav_hashek.pdf"
that doesn't even fit the line! Instead, Name it "schweik.pdf" and be
done with it.

Also, unless you are serving these files with a web-server or
something, avoid putting the `.txt' suffix there like some people
like to do. When one sees a file without a suffix (eh, extension) one
should ask the operating system: is this file executable? If it
isn't, well, it's probably plain text isn't it? These extra 4 bytes
at the end are superfluous, annoying and don't impress anyone.

Another thing is don't spread your files around. The reason there is
a separation between /etc/ and /usr/share/ is because people are
unlikely to copy the latter between hosts. On the other hand if you
install a, say, dictionary program, download some custom dictionaries
for it and decide that you want this program somewhere else, well,
you'll want to copy both your configs and the extra data files you've
downloaded. And now with the XDG directory specification this
operation no more as simple as `scp -r ~/.dict user@host:'! So, thank
you, XDG!

There are a several of reasons for separating closely-related files
into several directories:

1. It may help avoid naming collisions. For example, if I were to
make a note-taking program, I'd store all the notes in their own
directory and all the helper files in the directory above.

2. There may be other technical reasons. For the same program may
load different configs depending on a directory. git(1) is one
example of that.

3. You *actually* only want to have a subset of files visible at a
time. For instance, it may be good idea to keep old mail, however,
in the vast majority of cases one is only interested in the very
recent mail, so there is no need to load one's mailing program and
own brain with the old stuff, except when explicitly asked. One
solution is to move each prior year's mail into its own directory,
and only keep the current year's mail in the actual inbox.

Another thing people seem to like to do that is even worse than
creating those weird single-file directories is creating unreasonably
short files. I see this manifested primarily in two ways:

1. People decide that foo.conf is not enough somehow and instead
create foo.conf.d/ putting dozens of single-line files there.

2. There is this "style" of programming where people create separate
files for each function.

Now, firstly this sort of behaviour is very rude to your disc: I am
yet to encounter one with 20-byte-long sectors. Secondly, the only
purpose it serves is creating more busywork. Beforehand I had
everything I needed in the place where it logically should reside.
Now I have to jump from file to file just to figure out the meaning
of a single line. This, by the way, also relates to programming in
general.

Another issue is symlinks. Don't use them, unless there is some
strong reason to do so. There are several kinds of symlinks: those
between directories, which mostly just cause confusion. Those between
files on different filesystems, which don't even always work. And
there are symlinks between normal files on the same filesystem. These
should be hardlinks. The only "benefit" there is to be had from using
symlinks instead lies in confusing some poor program once the actual
file has been deleted, and the symlink it depended upon is no longer
pointing to some useful location.


For some more particular advice, here are directories in my ~:

	bin/ games/ lit/ mail/ misc/ src/ sync/ tmp/ vid/

~/bin/ is part of my PATH. This is where I put all my "permanent"
scripts.

~/misc/ and ~/tmp/ are both for files of varying degree of
temporariness. The first is where I put files when I either don't
know where else to put them yet, know where to put them, but don't
want to do that just yet, or intend to remove them later, yet would
like to hold on to them for now. ~/tmp/ is more temporal than that,
yet less so than /tmp/. This is where downloaded files and
screenshots land initially. This is also where I conduct experiments
that for whatever reason cannot be conducted in /tmp/.

The inner structure of ~/games/ is very much ad-hoc. You can guess
the rest.

~/lit/ is composed entirely of pdf files as of right now. A bit
surprisingly, getting untranslated foreign fiction on some dead-tree
paper is much, much simpler in Moscow, than getting untranslated
technical literature, even though one would think the translations of
the latter would be mostly useless. An interesting thing about
technical literature is that it's mostly reasonably self-contained,
and so there are hardly any book series I keep in this directory. The
ones that are there are put into their own subdirectory and
structured like so:

	~/lit/bookname/
	|-- bookname1.pdf
	|-- bookname2.pdf
	...
	`-- booknameN.pdf

Most of them, however, don't get their own directories, of course.

~/mail/ houses two kinds of maildirs: ones named
~/mail/{2021,2022,...}/ and ~/mail/in/. Stuff arrives into ~/mail/in/
and moves on to a newly-created maildir once a year has passed.

~/src/ is where I put the source code of various projects. Because I
commited to some projects using github, but I don't want the site to
expose my mail address, there is also the subdirectory ~/src/gh/,
which is pretty much the same, except that it has its own gitconfig.

~/sync/ contains files I sync between my local machine and my server.
I might change the hierarchy there slightly if I start maintaining
more systems on a regular basis. The internal hierarchy mostly
corresponds to that of the server's root, though there are a lot of
extra files in ~/sync/ itself like plan, profile, kshrc, sync.sh etc.
Hopefully the names are revealing enough.

~/vid/ contains Monty Python mostly. Somewhat similar in structure to
~/lit/, excepting that there are more subdirectories.


PROGRAMMING

There are already a lot of good stylistic references for C (and
probably for other languages, but we'll stick with C here). Good ones
in particular are OpenBSD's style(9) (google it on
http://man.openbsd.org) and the style employed by K&R in their book
"the C programming language". A lot of good advice is offered in
"the practice of programming" by Brian Kernighan and Rob Pike. Do
read those for a more complete overview of good style. Here I shall
instead go over some techniques that are critically underemployed
and some mistakes that

I find it very helpful to compile with flags
`-std=c99 -Wall -Wextra -pedantic -O0 -g'. Of course, this is just
for the debugging purposes, for "real" compilation you'd probably
remove at least the `-O0 -g'. Other than that, I don't find linters
to be particularly helpful -- they misreport all but too often. For
instance, I used to employ LLVM's scan-build(1) until discovering
that it complains about such code:

	void
	err(int eval, char *fmt, ...)
	{
		...
		exit(eval);
	}

	void
	somefunc(void)
	{
		char *ptr;
		if (!(ptr = malloc(n)))
			err(1, "bad malloc");
		*ptr = '\0';
	}

but not with this modification of somefunc:

	void
	somefunc(void)
	{
		char *ptr;
		if (!(ptr = malloc(n))) {
			err(1, "bad malloc");
			exit(1);
		}
		*ptr = '\0';
	}

So, the moral is: compile with -std=c99 -Wall -Wextra -pedantic, fix
warnings, test thoroughly, fix bugs as soon as they are found, avoid
common missteps, and don't rely on external linters.

Portable programs tend to not only cause much less pain, but to also
be better written in general, so try to stay within mainstream, only
using local extensions when necessary. Definitely do not rely on a
particular compiler's or standard library's quirk.

In the vast majority of cases code alignment (except indentation) is
a huge waste of effort that doesn't even pay off, so I avoid that.

When possible I position my functions starting on their own line like
so:

	int
	foo(void)
	...

this makes the code very easily grep(1)pable (grep ^foo\( *.c)). And
no need for ctags! Generally it is worth writing in a way that'll
make moving around simpler.

Side effects should generally be avoided, except for some
well-understood idioms like *a++ = *b++.

There are many programs whose portability depends upon preprocessor
instructions like #if and #ifdef. It is easily observed that even
in small number they can bring much confusion. Avoid such constructs
when at all possible. Even the debug macros are often not really
necessary. Compare the two:

	#define DEBUG

	#ifdef DEBUG
	printf("this is a debug statement\n");
	#endif /* DEBUG */

and

	enum = { DEBUG = 1 };

	if (DEBUG)
		printf("this is a debug statement\n");

If we set DEBUG to 0 in the second case, the compiler will optimise
the statement away in any case, but it'll warn us if we mess up the
actual debug code.

Comments are often used in silly ways. In fact some people even have
their editors configured to make the comments dimmer. In fact they
should have them configured to make comments brighter and/or bolder.
Comments are very powerful and should therefore be used with much
discretion. Good comments include the ones that go briefly over
functions and global data, and the ones which help the reader to
understand a complicated algorithm used in code. They should
definitely not, state the obvious, or be seen as a compensation for
bad code, which should be rewritten instead. Such comments have a
tendency of eventually contradicting the code, which is the great
danger of comments.

There are many examples of not just bad, but moronic comments:

	/*******************************************************
	 *                                                     *
	 *                                                     *
	 *                 MY HELLO WORLD ROUTINE              *
	 *                                                     *
	 *                                                     *
	 *******************************************************/

	do_stuff() //!!!

	/**** Maybe I should draw more asterisks... ****/

Don't laugh, I actually get paid for working with these!

And another thing is to definitely not just leave code commented out,
at least not after debugging. Though if you do write a debugging
function, leave it there, for you might need it in the future.

There are a lot of reasons to divide programs into multiple files. Do
create as many as are needed, especially for portability, and when
compilation becomes too long. Do not, however put things into new files
just for the sake of it. Many programmers seem to think that if they put
every single function into its own file it'll somehow make things
better. In fact it only makes their code a navigational nightmare.

Speaking of multiple files, don't include files in your included files.
There is, of course a "protection" often employ to avoid cycles:

	#ifndef THISFILE_H
	#define THISFILE_H
	#include "a.h"
	#include "b.h"
	/* file contents... */
	#endif /* THISFILE_H */

which does not, however, protect your preprocessor from processing
this rubbish over and over again, ensuring the program doesn't
actually finish compiling for a stupid multiplied by long amount of
time. Instead simply comment what files should be included before that
one and let the actual includer worry about what to include:

	/*
	 * Description of what the file is for.
	 *
	 * #include "a.h"
	 * #include "b.h"
	 * #include "thisfile.h"
	 */

A thing that I, thankfully, see more rarely, but still do sometimes
is variables getting burdened with as many qualifiers as the
programmer managed to come up with. In truth, there should be as
*few* qualifiers as possible. In particular many people seem to make
variables unsigned for no reason other than that they should never be
negative. That not only encourages integer overflow errors, but can
make the code much more complicated. Observe, for instance, this
piece of code, which calculates the column, corresponding to nth
character in some line:

	...
	for (off = 0, col = -1; off <= n; off++)
		if (s[off] == '\t')
			col = ((col+1)/8 + 1) * 8 - 1;
		else if (isprint(s[off]))
			col++;
	...

col here should never end up negative, however it is still useful to
assign it to -1 initially to simplify the program, and possibly to
indicate an error.

For the last I'll leave you with this bit of bad code that I've seen
too often:

	if (bad)
		return 0;
	else {
		/* The rest of the function's code here. */
	}

If you do that people will laugh at you. Instead write normally:

	if (bad)
		return 0;

	/* The rest of the function's code here. */
