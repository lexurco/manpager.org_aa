Even if I didn't know how to vocalise it, I considered the human
civilisation to be in a great decline since I was in the middle
school. Barbarians are very much at the gates, except this time
we who consider ourselves civilised are the barbarians.

There are quite a few things so important to the civilised society
that they precede even the formation of formal hierarchies. Chief
among them is, of course, agriculture. I don't think I am very well
qualified to judge the state of that, I will just say that only Islam
preserved that relatively intact in some places for the Moslems have
a need of the halal food. Then on his road to civilisation man also
needs to form a spirituality, for how else is he do be guided in his
decisions? In spite of that, the fact that we somehow managed to kill
Him within ourselves has been noted a couple of centuries before, and
things are even worse now. Civilised man also has a need for science,
as a civilisation without knowledge ceases to be civilised. The fact
that science is dead should be obvious to any graduate of a
university: we killed it with patents, standards and so-called
"antiplagiarism." Finally, a civilised man has a need for culture:
art and games, that which makes him satisfied intellectually. I am
very much convinced that we are on the road of replacing all art with
commerce and politics.

If we are to somehow slow down, or even reverse that process, I
believe that we need more art unburdened by propriety, licences and
cheap political messages. In particular that concerns computer games,
which at first weren't really considered an object of culture and
received instead the same terrible treatment that software
development did outside of the very few places, and which later
largely transformed into a monster similar to the BBC and Hollywood.
(Or Netflix and HBO, or whoever produces that rubbish nowadays.)

Unfortunately, even the people who understand the importance of being
free to have a culture usually concentrate so much on the
software-related aspects (DRM, freedom to inspect/modify the code,
etc.) that they forget completely that this artificial legalese
surrounds all other aspects of art as well. In computer games it is
now common to refer to all the more "traditional" (not programming)
art involved as mere "assets." In fact, it is somewhat common even to
allow the copying of the code, yet forbid that of the "assets." I
say, however that the assets are equally as important! There already
are countless programs we've lost due to the human greed and
commercialisation of art (yes, the art of computer programming), I do
not think that anyone reading this will need much convincing to
accept that statement. Yet there are also countless of "assets" we've
already lost due to the same stubbornness and vanity. Just look up
what happened to the early episodes of Doctor Who!

With my philosophy clearly stated I will proceed to list the games I
managed to play that were free completely -- i.e. neither the code,
nor the "assets" were burdened too much. Expect many more to appear
in the future.


ENDLESS SKY

https://endless-sky.github.io/

This must have been the first completely libre game that I have ever
played. At the time I was writing my baccalaurean diploma, and
whenever I do such projects I find it to be a good practice to take
short breaks and do something that is neither very mentally taxing
instead, nor allows my brain to retreat into the automatic state
completely. So far, nothing has been able to fit this description
entirely, but Endless Sky did come closer than some other things I'd
tried.

The game is pretty typical of the other top-down exploration/trading/
combating games. For the most part it consists of going to planets
and taking missions, considering one's travel route against the time
it'd take in order to maximise the profits. It also has quite a few
special missions, which make it all much more interesting. Overall,
the game really is quite impressive, however it is also not hard to
notice that many things in it are unfinished. In particular that
relates to these campaign-missions and the areas of the map that
become explorable afterwards. The former, it feels like, should have
much more branchings that should have a much bigger impact, while the
latter feels a bit too empty.

In conclusion, Endless Sky is a fantastic game that I can recommend
to anyone, and I wish the people working on it the best of luck.


BSD GAMES

Historically there've been a lot of games written for BSD that are
now usually available on most modern BSDs in /usr/games/, and can be
installed on Linuces from packages like bsd-games and similar. Most
famous of these games is probably rogue(6), which had many
descendants. I managed to play most that come with OpenBSD.

- adventure(6) is a bit of a classic. The later "adventure games" get
this label from it. The manual is very brief stating that part of the
game is figuring out the rules, and only stating that "quit" is for
quitting and "suspend" is for quitting but saving. Thankfully, when
launched, the game does provide a little bit of help and says that
further help is provided by commands "help" and "info." Otherwise the
game is played very much like the latter text-based adventures it
inspired: the player types one, or two words per command, consisting
of a verb and a noun, though one of the two can be omitted if it can
be inferred from the other. In order to play this game I also had to
draw the map on paper, which I wish more games would have forced me
to do. Another interesting feature of adventure(6) is that saving the
game involves quitting it, and then waiting at least 45 minutes
before continuing. It probably made quite a lot of sense when it was
originally written, and many people would connect to the same
mainframe from a terminal for a limited time, and even now I wish the
games would do that so that the player may also spend his free time
doing other things. Oh, well, at least most new games aren't as
insistent on the player not quitting as Id's games.

Unfortunately, adventure(6) would also lead to the issues that still
trouble similar games, namely that they are impossible to complete
while playing in any other way than through the players' collective
wisdom: really, how on Earth was I supposed to know that spooking a
giant snake is a matter as simple as releasing a small bird onto it
for some reason? Somehow I did manage to complete the thing through a
combination of my own wits, googling and backing up my saves, but in
the end I only received 330 out of 350 points, becoming an annoying
single point short of achieving the next rank.

- arithmetic(6) prints rather simple expressions like "6 + 5" and
"14 - 9" and waits for the user to input the answer. Occasionally it
also prints out the score. Not the most challenging, or creative
game.

- atc(6) is a brutal game. The man page states: Suspending a game is
not permitted.  If you get a talk message, tough. When was the last
time an Air Traffic Controller got called away to the phone? Neither
the rest of the man page, nor the game's UI were very telling: just
like a certain Monty Python character the only thing I know about
planes is that I flew some (and that the only worse travelling
experience I've had was in cars -- even metro at peak hours is
somehow better.) The controls are also quite hostile except for the
majority that types on QWERTY. Even for a player that managed to get
through all these things nothing but stress awaits -- and no wonder,
it puts the player into control of air traffic. Personally, I gained
a new appreciation of just how relaxed Doom is through atc(6).

- backgammon(6) is what it sounds like. It also includes the tutorial
invoked as teachgammon. Unfortunately, I have never had the pleasure
of playing actual backgammon, but I can recall trying to play nards,
which is a very similar games of Persian (I think) origin, mostly
known among the various Caucasian and Russian (and maybe Iranian, but
I wouldn't know) peoples. I've heard it's particularly popular among
the Armenians. Like most users of Unix I don't have a single friend
that understands a single sentence coming from my mouth even when I
merely quote, so in I went against the computer. I was, however,
rather worried. Strangely enough it was when I was writing my
diploma, which ended up having nothing to do with backgammon anyway,
that I discovered that backgammond is among those games, which
computers can't play effectively using only classical game theory.
Rather the only known more-or-less efficient backgammon-playing
programs so far have used some learning algorithm, or as they are
known among the proogers, the neural networks.

In any case, in I went typing "teachgammon" into my terminal. A bit
of surprise was that a lone piece (called "man" in this version) does
not deny the opponent's moves to the same position, but rather
becomes vulnerable, as the opposing man can land on him (it?),
sending the unfortunate man to the bar (position 0). On the next
turn the player will first have to bring all his men from the bar
before he or she is able to perform any other moves. I *think* this
is not the case in nards, where a piece cannot land on another, no
matter how many are there. Also, I think that in nards all pieces
start at the first position, rather than begin somewhat scattered
already.

Moments later I played a couple of parties as red because additions
are easier that subtractions. As I discovered, however, either this
is one of the good AIs, or I am completely, or I am completely
untrained myself.

- banner(6) and banner(1) are actually two different programs, though
their purpose is identical -- the printing of huge letters out of
number signs (#). Example output:

	$ /usr/games/banner ..
	                                   ######
	                                 ##########
	                                ############
	                               ##############
	                               ##############
	                               ##############
	                                ############
	                                 ##########
	                                   ######
	 
	 
	                                   ######
	                                 ##########
	                                ############
	                               ##############
	                               ##############
	                               ##############
	                                ############
	                                 ##########
	                                   ######
 
 
	$ /usr/bin/banner Unix
	#     #
	#     #  #    #     #    #    #
	#     #  ##   #     #     #  #
	#     #  # #  #     #      ##
	#     #  #  # #     #      ##
	#     #  #   ##     #     #  #
	 #####   #    #     #    #    #

- bcd(6) transforms input into an ASCII art representation of punched
cards and back. Sorry, but I am born too recently to know what it
means.

- boggle(6) -- I don't even know.

- bs(6) means "battleship". In real life the game is only slightly
better than naughts-and-crosses and is thus only played on the
especially boring occasions. Here it's not even multiplayer.

- caesar(6) also invoked as rot13 attempts to decypher Caesar's
cypher. There is probably a reason for this utility to exist...

- canfield(6) & cfscores(6). Although I am often critical of windows,
I don't think it's a completely terrible operating system. No OS that
features minesweeper can be such. Solitaire, however, is most
definitely a mistake. What even is solitaire? And you know what
canfield(6) is? Solitaire for Unix!

- cribbage(6) -- another card game.

- factor(6) and primes(6) work with the prime numbers. factor(6)
prints all prime factors of a number and primes(6) lists all primes in
a range.

- fortune(6) prints silly messages.

- gomoku(6) is a sort of naughts-and-crosses-on-19x19 board. The AI
is terribly slow as well: it may take dozens of seconds to think its
move.

- grdc(6) turns the terminal screen into a huge clock. Better than
xclock(1)! (which doesn't even seem to ever find an appropriate font
to use).

- hack(6) is like rogue(6) but full of bugs...

- hangman(6) is pretty much what one would have expected.

- hunt(6) is among the multiplayer BSD games that work on OpenBSD.
Unfortunately, I don't really know a lot of people that'd be willing
to try that out with me.

- mille(6) -- yet another product of Ken Arnold's overactiveness.
Seems to be a multi-player clone of some existing board game. I
did't go too much into details.

- monop(6) -- ah, yes, monopoly on my terminal.

- morse(6). Let me demonstrate:

	$ echo morse | morse
	dow daw
	daw daw daw
	dit daw dit
	dit dit dit
	dit

	dit dit dit daw dit daw

- number(6) reads number and converts it to English like so:

	$ number 129
	one hundred twenty-nine.

Of course, 129 as read as "one hundred *and* twenty nine," but oh
well...

- phantasia(6) unfortunately requires some other human beings to play
with and doesn't work on OpenBSD anyway.

- pig(6) translates sentences from English to pig Latin. Shame
bsdgames are usually not installed by default with most Linuces,
otherwise it'd be useful at work...

- pom(6) displays the phase of the moon similarly to how date(1)
does something useful.

- ppt(6) is a close relative of bcd(6), so I don't know what it means
either.

- quiz(6) the player some questions on a topic. Funnily there have
been quite a few very simple women that tried to convince me that the
quiz TV programmes are somehow educational. Well, sorry, but both the
quiz programmes and programs are the opposite of educational.

- rain(6) plays a nice animation.

- random(6) can either print random lines from input, or random
numbers, e.g.:

	$ man random | random
	RANDOM(6)                        Games Manual                        RANDOM(6)
	
	NAME
	     random â€“ random lines from a file or random numbers
	SYNOPSIS
	     random [-er] [denominator]
	
	DESCRIPTION
	     must be at least 1, its default value is 2.
	     The options are as follows:
	     -r      The -r option guarantees that the output is unbuffered.
	
	SEE ALSO
	OpenBSD 7.2                     August 23, 2022                    OpenBSD 7.2

- robots(6) is quite a lot of fun, actually! It's very simple as
well, so I'll finish that at that.

- sail(6) is currently same as phantasia(6), unfortunately.

- snake(6) is pretty similar to robots(6).

- I'd probably be more surprised were I to not find tetris(6).

- trek(6) is in somewhere between adventrue(6) and hack(6). It is
pretty complex, but pretty fun nonetheless and can be played without
first having to find anyone interested. Unfortunately the
documentation is rather weird. The man page only gives a brief
overview explanation of some commands, while the actual doc is not
distributed with OpenBSD. Oh, well, I do have the sources:

	$ tbl /usr/src/games/trek/USD.doc/trek.me | groff -Tascii |
	    less -r

Basically, the player is given a space-ship that responds to a number
of commands. A limited space is shared with several enemies friendly
planets etc. All enemies have to be destroyed before time runs out.
Personally I found the game to be very well-made and would argue that
it is a great example of how games should me made.

- wargames(6) is a very strange game indeed. My version is
implemented as a small shell script. Here is the code:

	echo -n "Would you like to play a game? "
	read x a
	x=`/usr/bin/basename $x`
 
	if [ -f /usr/games/$x ] ; then
		tput cl
		exec /usr/games/$x $a
	else
		echo "A strange game."
		echo "The only winning move is not to play."
	fi
	exit 0

- worm(6) is of the variety where apples make the worm bigger, not
the one where worms from the team A drown the ones from the team B
by exploding the ground they stand on.

- worms(6) is another nice animation.

- wump(6) is mostly a luck-based game. Like adventure(6) it features
a non-Euclidian cave. One room in this cave contains an evil wumpus
that has to be killed by guessing, which cave he is in, while some
others contain bottomless pits and bats. Fortunately, the player is
told which room he's in, which rooms are nearby and if there are any
bats/wumpuses/pits closely. Unfortunately, the player is never told
which ones are the dangerous rooms before it is too late, so really
there is no way to win other than by guessing.


ANARCH

https://gitlab.com/drummyfish/anarch

The game's made by one Miroslav Chizh of Moravia, quite an
interesting man (though personally I disagree with a lot that he
claims to believe). It mostly plays like a generic Doom clone. The
achievement here is mostly technical. Being a programmer myself I am
at a disadvantage when actually trying to describe any code. It is
also further complicated by the fact that Miroslav is one of those
annoying people who think that placing two extra spaces at the start
of a line indents it by one extra level. An interesting part here is
that the game has quite clearly defined back- and front-end, which is
most unlike other games, which rather only divide data, state and
logic.
